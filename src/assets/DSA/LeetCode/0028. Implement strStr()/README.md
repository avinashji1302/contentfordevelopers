# Knuth-Morris-Pratt Algorithm
 



KMP algorithm does pre-processing on the substring we are matching, so let's go through the pre-processing step first:

## Preprocessing:

Given a substring a a b a a a b we want to find repetitions and we would record them in an array we proceed by adding a character at each step to examine at first we just start with the first character since this substring is of length 1 there can be no repetition so we record 0. at the next step we look at a a we can see that the first character is equal to the last so our repetition is of length one and we record one now we examine three characters note that we are specifically looking at repetitions at the start and at the end even though there are two a's the ending character is b which does not match the first character so we will record zero here so in this way we are matching suffix with the prefix adding another character we have a at both the beginning and end so the suffix and prefix of length 1 are repeated so here we would record one note that inner characters do not match going forward now we have two a's at the beginning and two a's at the end so the matching suffix with the prefix is of length two going forward once again we would have that the matching suffix and prefix is of length two note the middle characters do not match so they cannot be part of the repeating pattern adding the last character now we have 3 characters match so pattern aab occurs both at the beginning and end so we record three i will first write up the code to build the prefix table then go through an example kmp algorithm constructs this table efficiently in linear time first i will initialize my table to be an array with 0 at the first index then we initialize i to 1 which represents the index we are looking in the string and we will need another pointer so we initialize j to be equal to zero and j represents the length of the repeating suffix prefix pair then we would do a while loop until i reaches the end of our string and in the end we will return the table inside of the while loop we care about three cases if the character at index i matches the character at index j if they do not match but j is greater than zero and then the last case that we care about is when the characters do not match and j is equal to zero i will fill in what we do for each condition as i go through the example we have a string a a b a a a b so here our table right now has just one element zero we initialize i to one and j to zero so j is under the first character while i is under the second character so when we compare i and j and they're equal that means that the repeating suffix has gotten longer than it was at the previous step so we can increment j by 1. then we can record inside of our table the current length of the repeating prefix which would be j so in this case i would record one here oh yeah and so here i incremented j to one and then recorded one in the table and finally i will need to increment i so that we could go on to examine the next character now when we compare the character at i and j they do not match however j in this case is greater than zero in this case we would update j to be equal to the value in the table at j minus one in this case we would get that the value at j minus one at index zero is zero so we will set j to zero notice that we want to give this index a chance to be compared to the current i index so we will start our while loop all over again and do the comparison and once again the two characters a does not equal to b and this time j is equal to zero so since we have a mismatch we will record zero in our table and then we want to increment i so that we could examine the next character now i is at index 3 and j is at index 0 and we have that a matches a so we have this first case so we will increment j then recorded in our table and then we will increment i then doing this comparison again we get that s i is equal to sj so our repeating prefix is definitely has gotten longer so we will record two in the table and then increment i now we finally get a mismatch between i and j so we have b does not equal to a so we hit this middle if else statement we know that this prefix and this suffix here they were the same and they were of length too so we could see if there is repetition of the suffix in our previously matching prefix and we would jump back to compare the character there this is what essentially performing this step does so we would take set j equal to the value of the table at j minus one so add one which would be one so j would move back one step and then we would compare j with i and now since they are equal we would record once again two in the table and then we would increment j and then record two in the table and then increment i once again the characters that i and j are equal to each other so we will increment j record three in the table and then increment i and now we have gone through the entire string so we can return our resulting table now let's go back to the first example and search for the substring using the prefix table since all the characters of the substring are unique the table will have four zeros starting at beginning we could start our comparison a matches b matches c matches but e does not match d up until letter d we can look at the substring and we can see that since all the characters are unique there won't be a repeating prefix and suffix to save us the effort of matching suffixes as prefixes we can look up the value at index 3 in our table to get our answer which is 0. in this case it means that there won't be a match here nor here so we are free to move our substring all the way down to start comparing the first character with e and since the characters don't match we will just keep moving on now when we do the comparison all characters match and we have found our pattern so the knowledge of the prefix table helps us skip ahead when there is a mismatch so we can achieve linear time complexity let's look at another example we have already computed a prefix table for this pattern so let's see how we can use it i will introduce variables i and j which will help us keep track of the letters we are comparing so when the letters match we can move i and j to compare the next characters and when they match we will move them over again so in this way when the characters match we increment both i and j by one and we keep going until we reach two characters that do not match we can see that in the substring just before the mismatching characters we have a repeating prefix suffix pair and if you look at the corresponding value in the table we see 2 which is the length of the repeating prefix suffix pair so it means that we need to move j to index 2 and try the comparison again now the characters match and we are free to proceed forward incrementing both i and j and actually the rest of the characters match so eventually i and j will reach the last characters and then we are done and we have found our substring so this was another example to try and develop intuition for kmp algorithm now let's code it up so in the main function i will still need to take care of the edge case and in the end if i don't find a match i will return -1 so first i will build my prefix table and initialize i and j then i will iterate through the characters of the string and substring so while i is less than string that length and while j is less than substring that length i will do my comparisons so i'm going to look at three cases when the character in the string at index i matches the character in the substring at index j i will increment i and j by one now if the characters do not match and j is greater than zero in this case i will set j to be equal to the value in my prefix table at j minus one and then if the characters do not match and j is equal to zero then i can just move on and increment i by one in the end if i exit this while loop and j is equal to substring that length that means we were able to get a match for every letter in the substring so we have found our substring inside of the string we would return the starting position of the substring which would be given by i minus j and if we don't find it then we would just return -1 a better way of writing it would be like this so if we have found the string then we return i minus j and i will delete this we haven't found it we will return minus one now the time complexity is given by o n plus m where n is the length of the string and m is the length of the substring because we take linear time to build this prefix table and then we take linear time on the order of n to go through this while loop space complexity is going to be o of m because we need to build up this prefix table which will have its length be equal to the length of the substring personally i have always found kmp algorithm to be quite challenging so i hope this video could save you some of the pain of learning kmp algorithm if you have any questions or suggestions let me know in the comment section and good luck with your studies